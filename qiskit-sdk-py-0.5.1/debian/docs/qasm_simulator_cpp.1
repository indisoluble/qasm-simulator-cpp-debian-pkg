.\"t
.\" Automatically generated by Pandoc 1.19.2.1
.\"
.TH "" "" "" "" ""
.hy
.SH NAME
.PP
\f[B]qasm_simulator_cpp\f[] \- C++ quantum circuit simulator with
realistic noise
.SH DESCRIPTION
.PP
\f[I]QASM Simulator\f[] is a quantum circuit simulator written in C++
that includes a variety of realistic circuit level noise models.
The simulator may be run as a command line application to evaluate
quantum programs specified by a \f[I]Quantum program OBJect
(\f[B]QObj\f[])\f[].
It may also be used as a local backend in the \f[I]Quantum Information
Software Kit (\f[B]QISKit\f[] (https://www.qiskit.org))\f[].
.SH USING THE SIMULATOR
.SS RUNNING THE COMMAND LINE
.PP
The simulator may be run as follows:
.IP
.nf
\f[C]
\&./qasm_simulator_cpp\ input.json
\f[]
.fi
.PP
where \f[C]input.json\f[] is the file name of a \f[B]Quantum program
object (qobj)\f[].
This is a JSON specification of a quantum program which can be produced
using the QISKit SDK.
.PP
It is also possible to pipe the contents of a qobj directly to the
simulator by replacing the file name with a dash \f[C]\-\f[].
For example:
.IP
.nf
\f[C]
cat\ input.json\ |\ ./qasm_simulator_cpp\ \-
\f[]
.fi
.SS SIMULATOR OUTPUT
.PP
By default the simulator prints a JSON file to the standard output.
An example simulator output for a qobj called from QISKit containing a
single circuit is:
.IP
.nf
\f[C]
{
\ \ \ \ "backend":\ "local_qasm_simulator",
\ \ \ \ "cpp_simulator_kernel":\ "qasm_simulator_cpp",
\ \ \ \ "id":\ "example_qobj",
\ \ \ \ "result":\ [{
\ \ \ \ \ \ \ \ "data":\ [{
\ \ \ \ \ \ \ \ \ \ \ \ "counts":\ {
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "00":\ 523,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "11":\ 501
\ \ \ \ \ \ \ \ \ \ \ \ },
\ \ \ \ \ \ \ \ \ \ \ \ "time_taken":\ 0.004356
\ \ \ \ \ \ \ \ },
\ \ \ \ \ \ \ \ "name":\ "example_circuit",
\ \ \ \ \ \ \ \ "seed":\ 3792116984,
\ \ \ \ \ \ \ \ "shots":\ 1024,
\ \ \ \ \ \ \ \ "status":\ "DONE",
\ \ \ \ \ \ \ \ "success":true
\ \ \ \ }],
\ \ \ \ "status":\ "DONE",
\ \ \ \ "success":true
\ \ \ \ "time_taken":\ 0.004366
}
\f[]
.fi
.PP
The \f[C]"result"\f[] key is a list of the output of each circuit in the
qobj: If the qobj contains \f[I]n\f[] circuits, \f[C]"result"\f[] will
be a length \f[I]n\f[] list.
The results for each individual circuit are obtained by the
\f[C]"data"\f[] key in the circuit result object.
Be default this will be a dictionary \f[C]"counts"\f[] of measurement
counts.
Additional simulation data may be returned by using config settings
discussed in the config settings section.
.SS COMPLEX NUMBER FORMAT IN JSON
.PP
In the raw output file, complex numbers are stored as a list of the real
and imaginary parts.
Eg.
for \f[I]z = a +ib\f[] the output of \f[I]z\f[] will be
\f[C][a,\ b]\f[].
Using this convention complex vectors and matrices are stored as one
would expect: as lists of complex numbers, and as lists of lists of
complex numbers respectively.
.SS RUNTIME ERRORS
.PP
If the simulator encounters an error at runtime it will return the error
message in the JSON file.
If the simulator is unable to parse or evaluate the input qobj file it
will return
.IP
.nf
\f[C]
{
\ \ \ \ "status":\ "FAILED",
\ \ \ \ "message":\ "error\ message"
}
\f[]
.fi
.PP
If a qobj contains multiple circuits failure of one circuit will not
terminate evaluation of the remaining circuits.
In this case, the output will appear as
.IP
.nf
\f[C]
{
\ \ \ \ "id":\ ...,
\ \ \ \ "config":\ ...,
\ \ \ \ "time_taken":\ ...,
\ \ \ \ "results":\ [
\ \ \ \ \ \ \ \ <circ\-1\ results>,\ <circ\-2\ results>,\ ...
\ \ \ \ ]
\ \ \ \ "status":\ "DONE"
}
\f[]
.fi
.PP
where for any circuit that encounted an error \f[C]<circ\-n\ result>\f[]
will be given by
\f[C]{"status":\ "FAILED",\ "message":\ "error\ message"}\f[].
.SH CONFIG SETTINGS
.PP
The following table lists all recognized keys and allowed values for the
config settings of the input qobj.
Any of these options may be specified at the \f[B]qobj\f[] config level,
or at the individual \f[B]circuit\f[] config level.
In the latter case, any circuit\-level config settings will override the
top level config settings.
.SS TABLE OF CONFIG OPTIONS
.PP
.TS
tab(@);
lw(3.9n) lw(3.9n) lw(3.9n) lw(3.9n).
T{
Key
T}@T{
Allowed Values
T}@T{
Default
T}@T{
Description
T}
_
T{
\f[C]"shots"\f[]
T}@T{
Integer > 0
T}@T{
1
T}@T{
The number of simulation shots to be evaluated for a given circuit.
T}
T{
\f[C]"seed"\f[]
T}@T{
Integer >= 0
T}@T{
Random
T}@T{
The initial seed to be used for setting the random number generator used
by the simulator.
Simulator output should be deterministic of fixed \f[C]"seed"\f[] and
\f[C]"shots_threads"\f[] values.
T}
T{
\f[C]"shots_threads"\f[]
T}@T{
Integer >= 0
T}@T{
1
T}@T{
Allows parallelization of the simulation by evaluating multiple shots
simultaneously.
Note that this will cause the simulator to use more memory.
T}
T{
\f[C]"data"\f[]
T}@T{
List of strings
T}@T{
None
T}@T{
This control what output data is reported after the simulation.
It is a list of string options which are specified in the Data table.
T}
T{
\f[C]"noise_params"\f[]
T}@T{
dict
T}@T{
None
T}@T{
This is a dictionary of noise parameters for the simulation.
The allowed noise parameters are specified in the Noise Parameters
table.
T}
T{
\f[C]"initial_state"\f[]
T}@T{
Quantum state
T}@T{
None
T}@T{
Allows the circuit to be initialized in a fixed initial state.
See the appropriate section for details.
T}
T{
\f[C]"target_states"\f[]
T}@T{
List of quantum states
T}@T{
None
T}@T{
Specifies a list of target quantum states for comparison with the final
simulator state if the \f[C]"inner_products"\f[] or \f[C]"overlaps"\f[]
\f[C]"data"\f[] options are used.
See the appropriate section for details.
T}
T{
\f[C]"renorm_target_states"\f[]
T}@T{
True
T}@T{
Bool
T}@T{
This option renormalizes all states in the \f[C]"target_states\f[]" list
to be valid quantum states (with norm 1).
If set to \f[C]False\f[] the target states will be used as input without
normalization.
T}
T{
\f[C]"chop"\f[]
T}@T{
double >= 0
T}@T{
1e\-10
T}@T{
Any numerical quantities smaller than this value will be set to zero in
the returned output data.
T}
T{
\f[C]"max_memory"\f[]
T}@T{
int
T}@T{
16
T}@T{
Specifies the maximum memory the simulator should use for storing the
state vector.
This is used in determining the maximum number of qubits for simulation,
and the number of shots to be evaluated in parallel.
T}
T{
\f[C]"max_threads_shot"\f[]
T}@T{
int
T}@T{
Number of CPU cores
T}@T{
This option may be used to limit the number of shot threads that can be
evaluated in parallel.
T}
T{
\f[C]"max_threads_gate"\f[]
T}@T{
int
T}@T{
Number of CPU cores/shots threads
T}@T{
This option may be used to limit the number of parallel threads that
should be used in updating the state vector when performing the state
vector update from quantum circuit operations.
T}
T{
\f[C]"threshold_omp_gate"\f[]
T}@T{
int
T}@T{
20
T}@T{
This options specifies the qubit number threshold for enabling
parallelization when performing the state vector update from quantum
circuit operations.
T}
.TE
.SS MAXIMUM QUBIT NUMBER
.PP
The maximum qubit number is determined by the \f[C]"max_memory"\f[]
config setting by using this value as an upper bound on ab estimate of
the memory requirements for storing the state vector of an \f[I]N\f[]
qubit system.
This limit is given by the largest \f[I]N\f[] such that \f[I]16 * 2N *
10\-9 <\f[] \f[C]"max_memory"\f[].
These values are:
.PP
.TS
tab(@);
l l l l.
T{
Qubits
T}@T{
Memory (GB)
T}@T{
Qubits
T}@T{
Memory (GB)
T}
_
T{
25
T}@T{
0.54
T}@T{
31
T}@T{
34.36
T}
T{
26
T}@T{
1.07
T}@T{
32
T}@T{
68.72
T}
T{
27
T}@T{
2.15
T}@T{
33
T}@T{
137
T}
T{
28
T}@T{
4.29
T}@T{
34
T}@T{
275
T}
T{
29
T}@T{
8.59
T}@T{
35
T}@T{
550
T}
T{
30
T}@T{
17.18
T}@T{
36
T}@T{
1100
T}
.TE
.SS USING PARALLELIZATION
.PP
If compiled with OpenMP support the simulator can use parallelization
for both the number of shots evaluated concurrently and for using
parallel threads to update the state vector when applying circuit
operations.
If OpenMP support is not available, then parallelization over shots is
still available using the C++11 standard library.
.PP
There are two types of parallel speedups available:
.IP \[bu] 2
Multithreaded parallel evaluation of shots (OpenMP and C++11)
.IP \[bu] 2
Multithreaded parallel update of the state vector for gates and
measurements (OpenMP only)
.PP
If M1 threads are used in parallel shot evaluation, and M2 threads are
used in parallel gate updates, then the total number of threads used is
M = M1 * M2.
.PP
The total number of threads used is always limited by the available
number of CPU cores on a system and is additionally controlled by
several other heuristics which will be discussed below.
These may be restricted further using the following configuration
options: \f[C]"max_memory"\f[], \f[C]"max_threads_shot"\f[],
\f[C]"max_threads_gate"\f[] \f[C]"theshold_omp_gate"\f[].
.SS PARALLEL EVALUATION OF SHOTS
.PP
If multiple shots are being simulated parallel evaluation of shots takes
precedence in the used of CPU threads.
The total number of threads used is limited by the \f[C]"max_memory"\f[]
config option and the number of qubits in the circuit.
For a given estimate of the memory requirements of a N\-qubit state, a
number of shot threads will be launched up to the lower number of: the
\f[C]"max_memory"\f[] limit, the number of shots, the number of CPU
cores, the "\f[C]max_threads_shot"\f[] config setting.
.SS PARALLEL STATE VECTOR UPDATE
.PP
The second type of parallelization is used to update large N\-qubit
state vectors in parallel.
This is only available if the simulator is compiled with \f[B]OpenMP\f[]
using the \f[C]\-fopenmp\f[] option.
Parallelization is activated when the number of qubits in a circuit is
greater than the number specified by \f[C]"theshold_omp_gate"\f[], and
it uses any remaining threads \f[I]after\f[] shot parallelization.
Once above the threshold the number of threads used \f[I]per shot
thread\f[] is given by the minimum of: the number of CPU cores/number of
shot threads (rounded down), the \f[C]"max_threads_gate"\f[] config
setting.
The default threshold is 20 qubits.
Lowering this may reduce performance due to the overhead of thread
management on the shared state vector.
.SS USING A CUSTOM INITIAL STATE
.PP
By default, the simulator will always be initialized with all qubits in
the 0\-state.
A custom initial state for each shot of the simulator may be specified
by using the config setting \f[C]"initial_state"\f[].
This maybe be specified in the QOBJ as a vector or in a Bra\-Ket style
notation.
If the initial state is the wrong dimension for the circuit being
evaluated then the simulation will fail and return an error message.
.SS QOBJ EXAMPLE
.PP
The following are all valid representations of the state \f[I]|psi> =
(|00> + |11> )/sqrt(2)\f[]
.IP \[bu] 2
\f[C]"initial_state":\ [0.707107,\ 0,\ 0,\ 0.707107]\f[]
.IP \[bu] 2
\f[C]"initial_state":\ [[0.707107,\ 0],\ [0,0],\ [0,0],\ [0.707107,0]]\f[]
.IP \[bu] 2
\f[C]"initial_state":\ {"00":\ 0.707107,\ "11":\ 0.707107}\f[]
.IP \[bu] 2
\f[C]"initial_state":\ {"00":\ [0.707107,\ 0],\ "11":\ [0.707107,\ 0]}\f[]
.PP
The input will be renormalized by the simulator to ensure it is a
quantum state.
Hence there is no difference between replacing the above inputs with
\f[C]"initial_state":\ [1,\ 0,\ 0,\ 1]"\f[].
.SS OUTPUT DATA OPTIONS
.SS TABLE OF CLASSICAL BIT CONFIG OPTIONS
.PP
.TS
tab(@);
lw(3.9n) lw(3.9n).
T{
Key
T}@T{
Description
T}
_
T{
\f[C]"classical_state"\f[]
T}@T{
Returns a list of the final classical register bitstring after each
shot.
T}
T{
\f[C]"hide_counts"\f[]
T}@T{
Hides the counts dictionary in the circuit results data.
T}
.TE
.SS TABLE OF QUANTUM STATE SNAPSHOT OPTIONS
.PP
If the \f[C]"snapshot"\f[] gate command is used to obtain a copy of the
simulator quantum state then an additional \f[C]"snapshot"\f[] field
will be added to the circuit results data.
.PP
The snapshot gate command is specified as
\f[C]{"name":\ "snapshot",\ "params":\ [j]}\f[] where \f[C]j\f[] is an
integer specifying the snapshot location.
For example, if a circuit contains a single snapshot command with
\f[C]j=0\f[], then the results will contain something like:
.IP
.nf
\f[C]
{
\ \ \ \ "data":\ {
\ \ \ \ \ \ \ \ "snapshots":\ {
\ \ \ \ \ \ \ \ \ \ \ \ "0":\ {
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "statevector":\ [[[1.0,\ 0.0],\ [0.0,\ 0.0]]
\ \ \ \ \ \ \ \ \ \ \ \ }
\ \ \ \ \ \ \ \ },
\ \ \ \ \ \ \ \ "time_taken":\ 0.001188
\ \ \ \ },
\ \ \ \ "name":\ "snapshot_example",
\ \ \ \ "seed":\ 1,
\ \ \ \ "shots":\ 1,
\ \ \ \ "status":\ "DONE",
\ \ \ \ "success":\ true
}
\f[]
.fi
.PP
The keys of the \f[C]"snapshot"\f[] dictionary are strings of the
integers \f[C]"j"\f[], each containing a dictionary of data of the
quantum state at the point of the snapshot.
By default this dictionary will contain a field \f[C]"statevector"\f[]
containing a list of quantum state vector for each simulation shot.
Note that if measurement optimizations are used to sample the outcome
for an ideal circuit with all measurements at the end, this list will
contain only a single vector.
Additional snapshot formats options can be specified using the following
config settings in the \f[C]"data"\f[] field list:
.PP
.TS
tab(@);
lw(3.9n) lw(3.9n).
T{
Key
T}@T{
Description
T}
_
T{
\f[C]"hide_statevector"\f[]
T}@T{
Removes the \f[C]"statevector"\f[] field from quantum state snapshot
data.
T}
T{
\f[C]"quantum_state_ket"\f[]
T}@T{
Adds a \f[C]"quantum_state_ket"\f[] field to the snapshot data showing a
list of the quantum states for each shot in ket\-form.
T}
T{
\f[C]"density_matrix"\f[]
T}@T{
Adds a \f[C]"density_matrix"\f[] field to the snapshot data showing the
density matrix obtained by averaging the snapshot over shots.
T}
T{
\f[C]"probabilities"\f[]
T}@T{
Adds a \f[C]"probabilities"\f[] field to the snapshot data showing a
list of the Z\-basis measurement outcome probabilities obtained by
averaging the snapshot over shots.
T}
T{
\f[C]"probabilities_ket"\f[]
T}@T{
Adds a \f[C]"probabilities_ket"\f[] field to the snapshot data showing
the Z\-basis measurement outcome probabilities in ket\-form obtained by
averaging the snapshot over shots.
T}
T{
\f[C]"target_states_inner_product"\f[]
T}@T{
Adds a \f[C]"target_states_inner_product"\f[] field to the snapshot data
showing a list of the inner products $_j
T}
T{
\f[C]"target_states_overlaps"\f[]
T}@T{
Adds a \f[C]"target_states_overlaps"\f[] field to the snapshot data
showing a list of the expectation value $
T}
.TE
.SH NOISE PARAMETERS
.PP
We now describe the noise model parameters used by the simulator
.SS GATE ERRORS
.PP
Gate errors are specified by the error name and a dictionary of error
parameters.
Gate names are
.PP
.TS
tab(@);
l l.
T{
Name
T}@T{
Operations Affected
T}
_
T{
\f[C]"id"\f[]
T}@T{
\f[C]id\f[]
T}
T{
\f[C]"CX"\f[]
T}@T{
\f[C]CX,\ cx\f[]
T}
T{
\f[C]"measure"\f[]
T}@T{
\f[C]measure\f[]
T}
T{
\f[C]"reset"\f[]
T}@T{
\f[C]reset\f[]
T}
T{
\f[C]"U"\f[]
T}@T{
\f[C]U,\ u0,\ u1,\ u2,\ u3,\ x,\ y,\ z,\ h,\ s,\ sdg,\ t,\ tdg\f[]
T}
T{
\f[C]"X90"\f[]
T}@T{
\f[C]U,\ u0,\ u1,\ u2,\ u3,\ x,\ y,\ z,\ h,\ s,\ sdg,\ t,\ tdg\f[]
T}
.TE
.PP
Note that \f[C]"U"\f[] and \f[C]"X90"\f[] implement different error
models.
\f[C]"U"\f[] specifies a single qubit error model for all single qubit
gates, while \f[C]"X90"\f[] specifies an error model for 90\-degree X
rotation pulses, and single qubit gates are implemented in terms of
noisy X\-90 pulses and ideal Z\-rotations.
If both \f[C]"U"\f[] and \f[C]"X90"\f[] are set, then \f[C]"U"\f[] will
\f[I]only\f[] effect \f[C]U\f[] operations, while \f[C]"X90"\f[] will
affect all other operations
(\f[C]u0,\ u1,\ u2,\ u3,\ x,\ y,\ z,\ h,\ s,\ sdg,\ t,\ tdg\f[]).
.PP
In terms of X90 pulses single qubit gates are affected as:
.IP \[bu] 2
\f[C]u1,\ z,\ s,\ sdg,\ t,\ tdg\f[] have no error (zero X\-90 pulses)
.IP \[bu] 2
\f[C]u2,\ h\f[]: have single gate error (one X\-90 pulse)
.IP \[bu] 2
\f[C]U,\ u3,\ x,\ y\f[] have double gate error (two X\-90 pulses)
.IP \[bu] 2
\f[C]u0\f[]: has multiples of X\-90 pulse relaxation error only
.PP
The following keys specifify the implemented error models for single
qubit gates:
.PP
.TS
tab(@);
lw(3.9n) lw(3.9n) lw(3.9n).
T{
Key
T}@T{
Values
T}@T{
Description
T}
_
T{
\f[C]"p_depol"\f[]
T}@T{
p >= 0
T}@T{
Depolarizing error channel with depolarizing probability \f[I]p\f[]
T}
T{
\f[C]"p_pauli"\f[]
T}@T{
list[3] or list[15]
T}@T{
Pauli error channel where the list specifies the Pauli error
probabilities.
Note that this list will be renormalized to a probability vector.
For 1\-qubit operations it is \f[C][pX,\ pY,\ pZ]\f[], for 2\-qubit
operations it is \f[C][pIX,\ pIY,\ pIZ,\ pXI,\ pXX,\ ....\ ,\ pZZ]\f[].
T}
T{
\f[C]"gate_time"\f[]
T}@T{
t >=0
T}@T{
The length of the gate.
This is used for computing the thermal relaxation error probability in
combination with the \f[C]"relaxation_rate"\f[] parameter for thermal
relaxation errors.
Thermal relaxation is implemented as \f[I]T1\f[] and \f[I]T2\f[]
relaxation with \f[I]T2 = T1\f[].
T}
T{
\f[C]"U_error"\f[]
T}@T{
unitary matrix
T}@T{
This is a coherent error which is applied after the ideal gate
operation.
T}
.TE
.SS EXAMPLE
.PP
A single qubit gate error with gate time of \f[I]1\f[] unit,
depolarizing probability \f[I]p = 0.001\f[], dephasing Pauli channel
with dephasing probability \f[I]pZ = 0.01\f[], and a coherent phase
error \f[I]exp(i 0.1)\f[]
.IP
.nf
\f[C]
"U":\ {
\ \ \ \ "p_depol":\ 0.001,
\ \ \ \ "p_pauli":\ [0,\ 0,\ 0.01],
\ \ \ \ "gate_time":\ 1,
\ \ \ \ "U_error":\ [
\ \ \ \ \ \ \ \ [[1,\ 0],\ [0,\ 0]],
\ \ \ \ \ \ \ \ [[0,\ 0],\ [0.995004165,\ 0.099833417]]
\ \ \ \ ]
}
\f[]
.fi
.SS SPECIAL OPTIONS FOR X90 AND CX COHERENT ERRORS
.PP
The CX and X90 gate have special keys for automatically generating
coherent error matrices.
This is not supported directly by the simulator, but is handled by the
QISKit backend in python.
.SS X90 GATE
.PP
A coherent error model for X\-90 rotations due to calibration errors in
the control pulse amplitude, and detuning errors in the control pulse
frequency may be implemented directly with the following keywords:
.IP
.nf
\f[C]
"calibration_error":\ alpha,
"detuning_error:\ omega
\f[]
.fi
.PP
In this case the ideal X\-90 rotation will be implemented as the unitary
$U_{X90} = \\exp\\left[ \-i (\\frac{\\pi}{2} + alpha) (\\cos(\\omega) X + \\sin(\\omega) Y ) \\right]$.
If a \f[C]"U_error"\f[] keyword is specified this additional coherent
error will then be applied after, followed by any specified incoherent
errors.
.SS CX GATE
.PP
A coherent error model for a CX gate implemented via a cross\-resonance
interaction with a the control pulse amplitude calibration error, and a
ZZ\-interaction error may be implemented directly with the following
keywords:
.IP
.nf
\f[C]
"calibration_error":\ beta,
"zz_error":\ gamma
\f[]
.fi
.PP
In this case the unitary for the CX gate is implemented as \f[I]UCX =
UL*UCR*UR\f[] where, \f[I]UCR\f[] is the cross\-resonance unitary, and
\f[I]UL\f[], \f[I]UR\f[] are the ideal local unitary rotations that
would convert this to a CX in the ideal case.
The ideal CR unitary is given by $ U_{CR} = $, where qubit\-0 is the
control, and qubit\-1 is the target.
The noisy CR gate with the above errors is given by $ U_{CR} = $,
.PP
If a \f[C]"U_error"\f[] keyword is specified this additional coherent
error will then be applied after, followed by any specified incoherent
errors.
.SS THERMAL RELAXATION ERROR
.IP
.nf
\f[C]
"relaxation_rate":\ r
"thermal_populations":\ [p0,\ p1]
\f[]
.fi
.PP
Specifies the parameters for the \f[I]T1\f[] relaxation error of a
system (with \f[I]T2=T1\f[]).
The probability of a relaxation error for a get of length \f[I]t\f[] is
given by $p_{err} = 1\-exp(\-t r) $.
If a relaxation error occurs the system be reset to the 0 or 1 state
with probability \f[I]p0\f[] and \f[I]p1 = 1\-p0\f[] respectively.
.PP
Note that for single qubit gates the relaxation error occurs the noisy
(or ideal) gate is not applied to the state.
.SS RESET ERROR
.PP
This error models the system being reset into an incorrect computational
basis state.
If used in combination with the \f[C]"reset"\f[] gate error, the gate
error is applied in addition \f[I]afterwards\f[].
.IP
.nf
\f[C]
"reset_error":\ p
\f[]
.fi
.PP
When a qubit is reset it be set to the 0 or 1 states with probabilities
\f[I]1\-p\f[] and \f[I]p\f[] respectively.
This error is applied \f[I]before\f[] the \f[C]"reset"\f[] gate error is
applied to the reset qubit.
.SS MEASUREMENT READOUT ERROR
.PP
This error models incorrectly assigning the value of a classical bit
after a measurement.
It does not affect the quantum state of the system at all, only the
classical registers.
If used in combination with the \f[C]"measure"\f[] gate error, the gate
error is applied first, and then the readout error is applied to the
measurement of the resulting quantum state.
.IP
.nf
\f[C]
"readout_error":\ m
\f[]
.fi
.IP \[bu] 2
If a system is measured to be in the 0 (or 1) state, the value recorded
in the classical bit will be correctly recorded as 0 (or 1) with
probability \f[I]1\-m\f[], and incorrectly recorded as 1 (or 0) with
probability \f[I]m\f[].
.IP
.nf
\f[C]
"readout_error":\ [m0,\ m1]
\f[]
.fi
.IP \[bu] 2
If a system is measured to be in the 0 state, the correct (0) and
incorrect (1) outcome will be recorded with probability \f[I]1\-m0\f[]
and \f[I]m0\f[] respectively.
.IP \[bu] 2
If the system is measured to be in the 1 state the correct (1) and
incorrect (0) outcome will be recorded with probability \f[I]1\-m1\f[]
and \f[I]m1\f[] respectively.
.SH FULL CONFIG SPECIFICATION
.PP
An example of a configuration file for a 2\-qubit circuit using all
options is given below:
.IP
.nf
\f[C]
"config":\ {
\ \ \ \ "shots":\ 4,
\ \ \ \ "seed":\ 0,
\ \ \ \ "max_memory":\ 16,
\ \ \ \ "max_threads_shot":\ 4,
\ \ \ \ \ "max_threads_gate":\ 4,
\ \ \ \ \ "threshold_omp_gate":\ 20,
\ \ \ \ "data":\ [
\ \ \ \ \ \ \ \ "classical_state",
\ \ \ \ \ \ \ \ "quantum_state_ket",
\ \ \ \ \ \ \ \ "density_matrix",
\ \ \ \ \ \ \ \ "probabilities",
\ \ \ \ \ \ \ \ "probabilities_ket",
\ \ \ \ \ \ \ \ "target_states_inner_product"
\ \ \ \ \ \ \ \ "target_states_overlaps"
\ \ \ \ ],
\ \ \ \ "initial_state":\ [1,\ 0,\ 0,\ 1],
\ \ \ \ "target_states":\ [
\ \ \ \ \ \ \ \ [1,\ 0,\ 0,\ 1],
\ \ \ \ \ \ \ \ [1,\ 0,\ 0,\ \-1]
\ \ \ \ \ \ \ \ [[1,\ 0],\ [0,\ 0],\ [0,\ 0],\ [0,\ 1]],
\ \ \ \ \ \ \ \ [[1,\ 0],\ [0,\ 0],\ [0,\ 0],\ [0,\ \-1]]
\ \ \ \ ],
\ \ \ \ "renom_target_states:\ True,
\ \ \ \ "chop":\ 1e\-10,
\ \ \ \ "noise_params":\ {
\ \ \ \ \ \ \ \ "reset_error":\ p_reset,
\ \ \ \ \ \ \ \ "readout_error:\ [p_m0,\ p_m1],
\ \ \ \ \ \ \ \ "relaxation_rate":\ r,
\ \ \ \ \ \ \ \ "thermal_populations":\ [p0,\ p1],
\ \ \ \ \ \ \ \ "measure":\ {
\ \ \ \ \ \ \ \ \ \ \ \ "p_depol":\ p_meas,
\ \ \ \ \ \ \ \ \ \ \ \ "p_pauli":\ [pX_meas,\ pY_meas,\ pZ_meas],
\ \ \ \ \ \ \ \ \ \ \ \ "gate_time":\ t_meas,
\ \ \ \ \ \ \ \ \ \ \ \ "U_error":\ matrix_meas
\ \ \ \ \ \ \ \ },
\ \ \ \ \ \ \ \ "reset":\ {
\ \ \ \ \ \ \ \ \ \ \ \ "p_depol":\ p_res,
\ \ \ \ \ \ \ \ \ \ \ \ "p_pauli":\ [pX_res,\ pY_res,\ pZ_res],
\ \ \ \ \ \ \ \ \ \ \ \ "gate_time":\ t_res,
\ \ \ \ \ \ \ \ \ \ \ \ "U_error":\ matrix_res
\ \ \ \ \ \ \ \ },
\ \ \ \ \ \ \ \ "id":\ {
\ \ \ \ \ \ \ \ \ \ \ \ "p_depol":\ p_id,
\ \ \ \ \ \ \ \ \ \ \ \ "p_pauli":\ [pX_id,\ pY_id,\ pZ_id],
\ \ \ \ \ \ \ \ \ \ \ \ "gate_time":\ t_id,
\ \ \ \ \ \ \ \ \ \ \ \ "U_error":\ matrix_id
\ \ \ \ \ \ \ \ },
\ \ \ \ \ \ \ \ "U":\ {
\ \ \ \ \ \ \ \ \ \ \ \ "p_depol":\ p_u,
\ \ \ \ \ \ \ \ \ \ \ \ "p_pauli":\ [pX_u,\ pY_u,\ pZ_u],
\ \ \ \ \ \ \ \ \ \ \ \ "gate_time":\ t_u,
\ \ \ \ \ \ \ \ \ \ \ \ "U_error":\ matrix_u
\ \ \ \ \ \ \ \ },
\ \ \ \ \ \ \ \ "X90":\ {
\ \ \ \ \ \ \ \ \ \ \ \ "p_depol":\ p_x90,
\ \ \ \ \ \ \ \ \ \ \ \ "p_pauli":\ [pX_x90,\ pY_x90,\ pZ_x90],
\ \ \ \ \ \ \ \ \ \ \ \ "gate_time":\ t_X90,
\ \ \ \ \ \ \ \ \ \ \ \ "U_error":\ matrix_x90
\ \ \ \ \ \ \ \ },
\ \ \ \ \ \ \ \ "CX":\ {
\ \ \ \ \ \ \ \ \ \ \ \ "p_depol":\ p_cx,
\ \ \ \ \ \ \ \ \ \ \ \ "p_pauli":\ [pIX_cx,\ pIY_cx,\ pIZ_cx,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pXI_cx,\ pXX_cx,\ pXY_cx,\ pXZ_cx,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pYI_cx,\ pYX_cx,\ pYY_cx,\ pYZ_cx,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pZI_cx,\ pZX_cx,\ pZY_cx,\ pZZ_cx],
\ \ \ \ \ \ \ \ \ \ \ \ "gate_time":\ t_cx,
\ \ \ \ \ \ \ \ \ \ \ \ "U_error":\ matrix_cx
\ \ \ \ }
}
\f[]
.fi
.SH ACKNOWLEDGEMENTS
.PP
The development and implementation of approximate noise models in this
software was funded by the Intelligence Advanced Research Projects
Activity (IARPA), via the Army Research Office contract
W911NF\-16\-1\-0114.
.SH AUTHORS
.IP \[bu] 2
Christopher J.
Wood (<cjwood@us.ibm.com>)
.IP \[bu] 2
John A.
Smolin (<smolin@us.ibm.com>)
.SH COPYRIGHT
.PP
Copyright (c) 2017 IBM Corporation.
All Rights Reserved.
